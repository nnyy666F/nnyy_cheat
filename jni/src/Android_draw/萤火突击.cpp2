#include "include/touch.h"
#include "include/函数库.h"
#include <stdio.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include "字体.h"
//#include "图标.h"
#include "结构体.h"
#include "●MyFun.h"
#include "初始化.h"
#include <unistd.h>
#include "imgui_impl_android.h"
#include "imgui_impl_opengl3.h"
#define 游戏包名 "com.netease.yhtj"
#define 活动 "com.netease.game.MessiahNativeActivity"
const int ppC=501;
Ptr ZMDX,yawPitch,准心X,准心Y=0;
bool IsRun1=false,qzdq=false,IsDraw=false,ldkq=false,qrzs=false,qdl=false,xrl=false,xsl,IsAdopt,bcpz,cspz,输出日志,已初始化,修复了,log_IsClear,点击了,点击了2,copy_T,写入了,创建过,IsDown=false,IsDraw2=false,写入日志0,点击了0=true,b_atuo,p_open=false;
unsigned short zmfw,hjhp,IsVacate,index,OffSet,pidTg,Iskh,Gmin,WorldDistance=0,出现过1,khll;
float FPS=60,hdjl,objhp,sjw,lddx,ldpx,ldpy,khdx,khpx,khpy,雷达范围,ztpy,czpy,currXdis,currYdis,currDis,tempDis,背敌,y_start,y_start2,倒地血量,ac,ldx,ldy,c_x,c_y,obj_x,obj_y,对象血量,leenx,leeny,fwx,fwy,fkg,fkk,fwdx,Svalue,kjll=2;
char str[128];
char W_text[512];
char AllCount[ppC];
    ImVec2 now_pos;	
	char 标题1[64];
	unsigned short endPar=40;
	const unsigned short Per=125;
	//const float LdValue=2.08f;
	float DrawHp=100-0.01;
	char tempName[64];
	char tempName2[64];
	char objName[64];

bool IsRun(){pidTg=取PID("org.telegram.messenger");if(pidTg<=0){return false;}return true;}

void H_move()
{
	float x = 500,y = 10;
	Touch_Down(slot,x,y);

	for (; y<500; y += 4)
	{
		Touch_Move(slot,x,y);
		usleep(1000000/30);
	}
	usleep(10000);
	Touch_Up(slot);
}

void V_move()
{
	float x = 100,y = 100;
	Touch_Down(slot,x,y);

	for (; x<300; x += 3)
	{
		Touch_Move(slot,x,y);
		usleep(1000000/30);
	}
	usleep(10000);
	Touch_Up(slot);
}

void styleChange()
{
	switch (菜单.其它.selectedTopic)
	{	
	case 0:
		StyleColorsClassic();
		break;
	case 1:
		StyleColorsDark();
		break;
	case 2:
		StyleColorsLight();
		break;
	case 3:
		StyleColorsBlack();
		break;
	default:
		StyleColorsMagenta();
		break;
	}
}

void DrawUI()
{
	static bool w_open=true;
	//static auto TestImage = createTexture("/sdcard/icon.png");
	if(!w_open)
	{
		static bool 未清除=true;
		if(未清除)
		{
			清屏();
			未清除=false;
			puts("运行结束√ ");
			//shutdownSurface();
			stop();
			shutdownSurface();
			exit(1);
		}
	}
	
	/*  if(w_open){
		if(点击了){
        SetNextWindowPos({ 1111/2,40},0);
    	点击了=false;
    	}*/
    	IsDraw2=false;
    	auto tempFPS=GetIO().Framerate;
   	    sprintf(标题1,"X浏览器 (纯c内核)%.1fFPS ###Menu",tempFPS);
    	Begin(标题1,&w_open,ImGuiWindowFlags_AlwaysAutoResize);
    		if(BeginTabBar("Tab",ImGuiWindowFlags_AlwaysAutoResize)){    		
    	    IsDraw=true;
	        if(BeginTabItem(" 主页面 "))
	        {
	            sprintf(str,"游戏进程状态：%d%s\n",jczt,jczt==0 ? "(前台)" : "(后台)");
	            Text("已附加PID：%d\n到CB：%s",pid,"无");          
	            Text("屏幕高：%d,屏幕宽：%d",屏幕宽,屏幕高);
                Text(str);          
                Text("配置路径：%s",配置路径);          
                //Text("平均帧数 %.3f ms / 实时帧数 (%.1f FPS)",1000/tempFPS,tempFPS);
                //if(px!=0||py!=0){Text("屏幕高：%d屏幕宽：%d",屏幕宽,屏幕高);}else{Text("屏幕高：%s\n屏幕宽：%s","异常","异常"/*atosl(1,false,128)*/);}   
                //if(!修复了&&px==0||py==0/*屏幕宽==0||屏幕高==0*/){if(Button("分辨率异常？点我修复",ImVec2(500,80))){if(IsMiui()){if(jczt==0){system(cmd2);}usleep(1000000*1);system(cmd3);px=px.0;py=py.0;}else{if(jczt==0){system(cmd4);}usleep(1000000*1);system(cmd3);}菜单.人物.启停=true;修复了=true;写入日志("修复分辨率成功！\n");}}                  
                Checkbox("初始化",&菜单.人物.启停);
			    Checkbox("骨骼",&菜单.人物.骨骼);
                SameLine();
                Checkbox("方框",&菜单.人物.方框);
                SameLine();
				Checkbox("胸点",&菜单.人物.胸点);
				SameLine();
				Checkbox("射线",&菜单.人物.射线);
                
				Checkbox("血量",&菜单.人物.血量);
                SameLine();
                Checkbox("距离",&菜单.人物.距离);
                SameLine();
				Checkbox("名字",&菜单.人物.名字);
                SameLine();
                Checkbox("统计",&菜单.人物.统计);               
                Checkbox("信息",&菜单.人物.信息);
                SameLine();
				Checkbox("预警",&菜单.人物.预警);
				SameLine();
				Checkbox("人数",&菜单.人物.人数);
				SameLine();
				Checkbox("雷达",&菜单.人物.雷达);
				SameLine();
				Checkbox("背线",&菜单.人物.背敌);
				/*SameLine();
				Checkbox("全图高亮",&菜单.人物.全图高亮);
				SameLine();
				Checkbox("骑人",&菜单.人物.骑人);
				SameLine();
				Checkbox("吸人",&菜单.人物.吸人);
				SliderFloat("人物速度(默认1)",&菜单.人物.人物速度,0,10);*/			
				Text("竞赛模式选择");
				if(RadioButton("正常",&菜单.模式选择.模式,0)){菜单.模式选择.模式=0;}
			    SameLine();
                if(RadioButton("个人",&菜单.模式选择.模式,1)){菜单.模式选择.模式=1;}
                SameLine();
                if(RadioButton("吃鸡",&菜单.模式选择.模式,2)){菜单.模式选择.模式=2;}
                if(菜单.模式选择.模式==2){qrzs=true;}else{qrzs=false;}
                //if(qrzs){SliderInt("队伍人数(默认4人)",&菜单.人物.队伍人数,1,4);}
                SliderFloat("绘制帧率(默认60FPS)",&菜单.自瞄选择.总帧率,1,144);
				SliderFloat("雷达大小(默认10)",&菜单.人物.雷达大小,0,100);		
				SliderFloat("雷达水平X",&菜单.人物.雷达x,0,屏幕宽);
				SliderFloat("雷达水平Y",&菜单.人物.雷达y,0,屏幕高);
				SliderFloat("整体偏移X",&菜单.人物.整体x,0,屏幕宽);
				SliderFloat("垂直偏移Y",&菜单.人物.垂直y,0,屏幕高);		
				EndTabItem();		
				}				
			if(BeginTabItem(" 调自瞄 ")){
            IsDraw2=true; 
            Spacing();//间距
            Checkbox("自瞄初始化",&菜单.自瞄选择.自瞄开关);
            Text("横屏方向");
			if(RadioButton("充电接口朝右",&菜单.自瞄选择.横屏方向,0)){菜单.自瞄选择.横屏方向=0;}
			SameLine();
			if(RadioButton("充电接口朝左",&菜单.自瞄选择.横屏方向,1)){菜单.自瞄选择.横屏方向=1;}
			Text("自瞄模式");
			if(RadioButton("半屏",&菜单.自瞄选择.锁定部位,0)){菜单.自瞄选择.锁定部位=0;}
			SameLine();
            if(RadioButton("框内",&菜单.自瞄选择.锁定部位,1)){菜单.自瞄选择.锁定部位=1;}
		/*	SameLine();
            if(RadioButton("腰部",&菜单.自瞄选择.锁定部位,2)){菜单.自瞄选择.锁定部位=2;};  */
            Text("自瞄模式选择");
            if(RadioButton("开镜",&菜单.自瞄选择.自瞄模式,0)){菜单.自瞄选择.自瞄模式=0;}
			SameLine();
            if(RadioButton("开火",&菜单.自瞄选择.自瞄模式,1)){菜单.自瞄选择.自瞄模式=1;}
			SameLine();
            if(RadioButton("开镜开火",&菜单.自瞄选择.自瞄模式,2)){菜单.自瞄选择.自瞄模式=2;}
            if(CollapsingHeader("触摸区域设置")){		
            Text("触摸区域设置");
            SliderFloat("X轴(默认1200PX)",&菜单.自瞄选择.自瞄x,0,屏幕宽);
            SliderFloat("Y轴(默认550PX)",&菜单.自瞄选择.自瞄y,0,屏幕高);			
			SliderFloat("垂直偏移(默认0.5)",&菜单.自瞄选择.垂直偏移,0,1.0f);
			SliderInt("自瞄速度(默认10%)",&菜单.自瞄选择.自瞄速度,1,100);	
			SliderFloat("垂直触发(默认1)",&菜单.自瞄选择.自瞄范围Y,0.1,1);	
			SliderFloat("预判量(默认0.5)",&菜单.自瞄选择.预判倍率,0.5,12);	
			//SliderInt("自瞄范围(默认100%)",&菜单.自瞄选择.自瞄范围,0,100);					
			//SliderFloat("微调",&菜单.自瞄选择.垂直微调,0,0.1f);
			}
			if(CollapsingHeader("开火区域设置")){			
			Text("开火键区域设置");		
			SliderFloat("区域大小",&菜单.自瞄选择.区域大小,0,100);				
			SliderFloat("区域X",&菜单.自瞄选择.区域x,0,屏幕宽);
			SliderFloat("区域Y",&菜单.自瞄选择.区域y,0,屏幕高);		
			}
    	//if(Button("抢夺屏幕")) 	
       // if(Button("滑动状态栏")){
        //if(jczt==0){
        //横屏
      //  V_move();
       // }else {
         //竖屏
      //  H_move();
     //   }                   
     //   }
        EndTabItem();		
        }
        if(BeginTabItem(" 调配置 ")){
         if(Button("保存配置",ImVec2(500,80))){保存配置();bcpz=true;}
         if(Button("初始配置",ImVec2(500,80))){初始化配置();cspz=true;}
		 if(bcpz){Text("保存配置成功！");}if(cspz){Text("初始配置成功！");/*结束();exit(-1);*/}
		 const char*items[] = {"经典", "深色", "浅色","黑色[自创]","炫彩蓝[自创]"};	
		 Combo("主题选择", &菜单.其它.selectedTopic, items,IM_ARRAYSIZE(items));		
		 styleChange();		
		 SliderInt("方框_骨骼粗细(默认2)",&菜单.其它.RectWidth,0,5);
         SliderInt("射线粗细(默认1)",&菜单.其它.LineWidth,0,5);
         SliderInt("胸部绿点(默认5)",&菜单.其它.ChesteWidth,0,8);
		 SliderInt("背景图层(默认5%)",&菜单.其它.BackgroundLayer,1,99);
         SliderInt("可视度(默认100%)",&菜单.其它.VisiBility,10,100);
         //ColorEdit3("方框颜色",(float *) &菜单.其它.RectColor);        	
         float R=菜单.其它.R*2.55,G=菜单.其它.G*2.55,B=菜单.其它.B*2.55;         
         string str="配置颜色调节\n当前为：#%02lx%02lx%02lx";
         Text(str.c_str(),(int)R,(int)G,(int)B,ImVec2(500,80));
         SliderInt("R",&菜单.其它.R,0,100);  
         SliderInt("G",&菜单.其它.G,0,100);
         SliderInt("B",&菜单.其它.B,0,100);
         EndTabItem();		
         }else{if(bcpz){bcpz=false;}if(cspz){cspz=false;}}
      //  }
         EndTabBar();
        }else{        
    	IsDraw=false;
        }
    /* }else{ //if(now_pos.x<=0||now_pos.y<=0){SetNextWindowPos({ 60,60 },0);}

	    if(ImGui::Begin("悬浮窗",NULL,ImGuiWindowFlags_NoBackground||ImGuiWindowFlags_NoTitleBar 
	    ||ImGuiWindowFlags_NoSavedSettings||ImGuiWindowFlags_HorizontalScrollbar||ImGuiWindowFlags_NoResize)){
	    ImGui::SetWindowSize({ 150 ,150 });//设置窗口大小

	    if(ImGui::IsItemActive()){ if(!b_atuo){ b_atuo=true; now_pos=ImGui::GetWindowPos(); 点击了=true;
	    点击了2=true;




	    } }else if(b_atuo){ //点击了=false; b_atuo=false;


	    if(now_pos.x==ImGui::GetWindowPos().x&&ImGui::GetWindowPos().y==now_pos.y ){ w_open=true;

	    } } Image(TestImage.textureId,ImVec2(150,150),ImVec2(0,0),ImVec2(1,
	    1),ImVec4(1,1,1,1),ImVec4(0,0,0,0)); } } */        
}
Ptr 对象0[ppC]={};	   
unsigned short  对象数量2=0;
//char*停止文件1;
//void 取oom_adj(){/*usleep(1000000*1);*/for(;;){jczt=getProcessStatus(0);usleep(1000000*3);}}
float r_xx[ppC]={};
float r_yy[ppC]={};
float r_ww[ppC]={};
float 对象x[ppC]={};
float 对象y[ppC]={};
float 对象z[ppC]={};
float bjx[ppC]={};

void quickSort(float arr[],int low,int high){//降序
    if(high<=low)return;
    int i=low,j=high+1;
    int key=arr[low];
    while(true){
        while(arr[++i]>key){
            if(i==high)
                break;
        }
        while(arr[--j]<key){
            if(j==low)
                break;
        }
        if(i>=j)break;
        float temp=arr[i];
        arr[i]=arr[j];
        arr[j]=temp;    
    }
        key=arr[j];
        arr[j]=arr[low];
        arr[low]=key;
        quickSort(arr,low,j-1);
        quickSort(arr,j+1,high);
}

bool IsGetN=true;
unsigned short  tempCount[9999]={};
float 计算矩阵[4][4];
void*世界线程(void*arg)
{	
	对象数据*data=&初始化哦.对象;	
	for(;;)
	{			
	//printf("312\n");
	        if(jczt==1){清屏();cout<<GM_error<<endl;exit(1);}else if(jczt!=0){usleep(1000000*1);continue;}		 
			unsigned short  索引=0;				
			数组= 到64(到64(libil2cpp+ 0x499d930) + 0x70);
			

			
			data->数量=200;//到整数(数组指针+8);
			//if(data->数量<0||data->数量>30000||数组指针<0xfffff)	continue;			
					
		
			/*kjll=到小数(自身+0x1e0);
			
			khll=到整数(到64(自身+0x1e8)+0x168);*/
			
			//unsigned short TeamArr[9999]={};

			for (int i=0;i<data->数量;i++)
			{
				对象=到64(数组+8*i);
				//int 特征值=到整数(对象+0x130);
				//data->对象血量=到小数(到64(对象+0x568)+0x1C);		  	            	
//printf("331");
//printf("333\n");
        
        
				if(到整数(到64(到64(对象+0x1d8)+0x28)+0x50)==30)
				{	
				   // if(菜单.模式选择.模式==2&&i<菜单.人物.队伍人数) continue;						
				   // if(菜单.模式选择.模式!=0){取昵称(objName,到64(到64(对象+0x568)+0x128)+0x14);}				
					//data->对象阵营=到整数(到64(对象+0x568)+(菜单.模式选择.模式!=2?0x38:0x164));					
					if(到整数(对象+0x60)>0||到整数(对象+0x130)>4)
					{
					//	continue;
					}
				
					/*if(菜单.模式选择.模式==2&&data->对象阵营==data->自身阵营)
					{//过滤其它模式
					    continue;
					}*/
					if(0/*到小数(到64(对象+0x568)+0x1C)<=0 *//* &&data->自身血量>0 */ )
					{
						//continue;
					}
					//printf("352\n");
					对象0[索引]=对象;
					索引++;
					//TeamArr[data->对象阵营]++;		 
					//printf("312\n");					
				
               // printf("%d+%f\n",i,计算矩阵[i]);
					
					//bjx[i+1]=(r_xx[索引]-(r_yy[索引]-r_ww[索引])/24)-10;

				}			
				
			}
			
				//if(data->数量>0){
		        //tempCount[data->对象阵营]=TeamArr[data->对象阵营];       
		        对象数量2=索引;	
		        //}
			   // if(对象数量2==0&&data->自身血量>0&&菜单.模式选择.模式==0){颜色初始化();/*防止阵营写死，颜色一尘不变*/}
			    usleep((1000*0.1*1000)*(60/FPS));
			  //  printf("365");
	}
}

struct AimStruct
{
	float x,y,ScreenDistance=0;
	int WorldDistance=0;
	// 世界距离
} Aim[100] ={0};

float pmjl[100]={};
float zmx[100]={};
float zmy[100]={};
float zmxx[100]={};
float zmyy[100]={};
float zbx[100]={};
float zby[100]={};
float r_w[100]={};
float objhp1[100]={};
int AimPosition,bb=0;
int szs=0;
bool khl=false;
bool kjl,sdl,aa,wcr,lgl=false;
bool tql=true;
// 自瞄位置
int FindTar()
{
	//float min=px/2;
	int minAt=999;
	int ii=0;
/*	for (int i=0;i<对象数量2;i++)
	{*/
	//if(false){ii=bb;}else{ii=0;}
	float ydjl=pmjl[ii]/*sqrt(pow(px-r_xx[ii],2)+pow(py-(r_yy[ii]+((r_ww[ii]-r_yy[ii])/2)/1),2))*/;
	/*	if(ydjl<min&&ydjl!=0)
		{
    */
			//min=ydjl;
			minAt=0;
			obj_x=zmy[ii]/*py*2-(r_yy[ii]+((r_ww[ii]-r_yy[ii])/2)/1)*/;
	        obj_y=zmx[ii]/*r_xx[ii]*/;
	        hdjl=/*Aim[ii].ScreenDistance*/ydjl;	
            /*objhp=objhp1[ii];
	        sjw=r_w[ii]; */
	       // WorldDistance=Aim[ii].WorldDistance;
	//	}		
//	}
	if(minAt==999)
	{
		Gmin=-1;
		return -1;
	}
	Gmin=minAt;	
	return minAt;
}
float tqll[1];
float xdwz[1];
float xdwz2[1];

void 取预判()
{
	for (;;)
	{
		if (!菜单.自瞄选择.自瞄开关||!菜单.人物.启停||jczt!=0||对象数量2==0)
		{
			usleep(1000000*1);
			continue;
		}
		/*if (Gmin == -1 |||| Gmin == 100)
			continue;*/
			FindTar();
			//printf("前：%f %f\n",obj_x,obj_y);
		xdwz[0] = zmxx[0];
		xdwz[1] = zmyy[0];
		//printf("1S前：%f,%f\n",xdwz[0],xdwz[1]);
		usleep(10000*1);
		//printf("后：%f %f\n",obj_x,obj_y);
		xdwz2[0] = zmxx[0];
		xdwz2[1] = zmyy[0];
		//printf("1S后：%f,%f\n",xdwz[0],xdwz[1]);
		/*for (int i = 0; i < 2; i++)
		{*/

			tqll[1] = xdwz2[1] - xdwz[1];
			//tqll[0],是水平X坐标差，反之
			if(tqll[1]==0) puts("静止↓") ;
			else if(tqll[1]>0) puts("右→") ;
			else puts("左←") ;
			printf("%f\n",tqll[1]);
			if (对象数量2==0)
			{
				// printf("tqll:%f\n",tqll[0]);
				continue;
				// return -1;
			}
			usleep(10000/*0.8*(60/FPS)*/);
		//}
	}

}

bool bFirstDown[10];
extern TouchFinger **Fingers;
extern float x_proportion, y_proportion;
void TouchCallback(TouchFinger * finger)
{
        //usleep(1000000*1);
      //  return;
		int slot1 = ((uintptr_t) finger - (uintptr_t) & Fingers) / sizeof(TouchFinger);
		/*finger->x += 150 * x_proportion;
	    finger->y += 150 * y_proportion;*/
		if (finger->status == FINGER_UP)
		{
			bFirstDown[slot1] = false;
		}
		else
		{
			if (IsDown & !bFirstDown[slot1] & finger->x < py & finger->y > px)
			{
				// 这个就是第一次按下
				bFirstDown[slot1] = true;
				Touch_Up(slot1);
				IsDown = false;
			}
		}
}

float ty = 菜单.自瞄选择.自瞄y, tx = 菜单.自瞄选择.自瞄x;
void 触摸线程()
{
	double w = 0.0f, h = 0.0f, cmp = 0.0f;
	double touchX = 0, touchY = 0;
	对象数据*data = &初始化哦.对象;
	//static unsigned short i=0;
	for (;;)
	{
	if(!qdl){GrabTouchScreen();qdl=true;}
		/* obj_x+=tqll[0]; obj_y+=tqll[1]; */
		if (jczt != 0)
		{
			usleep(1000000*1);
			continue;
		}
		if (py <= 0 || px <= 0)
		{
			py = 屏幕高/2;
			px = 屏幕宽/2;
		}
		if (!菜单.自瞄选择.自瞄开关||!菜单.人物.启停)
		{
			if (IsDown)
			{
				ty = 菜单.自瞄选择.自瞄y, tx = 菜单.自瞄选择.自瞄x;
				// 恢复变量 
				Touch_Up(slot);
				// 抬起
				IsDown = false;
			}
			usleep(1000000*1);
			continue;
		}
		int aa = FindTar();
		/* obj_x+=tqll[0]; obj_y+=tqll[1]; */
		if (/*Gmin == -1*/false)
		{
			if (IsDown)
			{
				ty = 菜单.自瞄选择.自瞄y, tx = 菜单.自瞄选择.自瞄x;
				// 恢复变量 
				Touch_Up(slot);
				// 抬起
				IsDown = false;
			}
		    usleep(1000000*1);
			continue;
		}
		// if(sjw<=0) usleep(1000/FPS*1000/*(30-(FPS/144)*30)*1000*/);continue;
		if ((kjl/*l < 2.9 */ & /* khll != 0 */ khl) &  
    (菜单.自瞄选择.自瞄模式 == 2) ||  
    (kjl/*l < 2.9 */ & 菜单.自瞄选择.自瞄模式 == 0) ||  
    (/* khll !=0 */ khl & 菜单.自瞄选择.自瞄模式 == 1))
		{
		/*i++;
		if(i==1) usleep(1000/FPS*1000/*(30-(FPS/144)*30)*1000);continue;*/
			// if(obj_x==0&obj_y==0) usleep(1000/FPS*1000/*(30-(FPS/144)*30)*1000*/);continue; 
			// hdjl=sqrt(pow(px-(obj_x+tqll[0]),2)+pow(屏幕高-(obj_y+tqll[1]),2));						
			if(对象数量2<=0/*||objhp<=0*//*||hdjl==0*/||obj_x<=0&obj_y<=0/*||sjw<=0 ||到整数(自身+0x17cc)==1*/){usleep(1000/FPS*1000/*(30-(FPS/144)*30)*1000*/);continue;}	
			//printf("%f,%f\n",obj_x,obj_y);
			GrabTouchScreen();			
			if (1)//菜单.自瞄选择.锁定部位==0 || obj_x >= px - fkk / 2 & obj_x <= px + fkk / 2 & 菜单.自瞄选择.锁定部位==1 || obj_y >= px - fkk / 2 & obj_y <= px + fkk / 2 & 菜单.自瞄选择.锁定部位==1)
			{
				/* float tql=0; if(tqll[1]>fkk) tql=fkk; */			
				if (!IsDown)
				{
					Touch_Down(slot, ty, tx);
					IsDown = true;
					//usleep(1000/FPS*1000/*(30-(FPS/144)*30)*1000*/);
				}
				if (obj_x <= py)
				{
					w = py - obj_x;
					leenx /= 菜单.自瞄选择.自瞄速度;
					if (leenx <= 10.0f){
						leenx = (hdjl /* +tql */ ) / (菜单.自瞄选择.自瞄速度);
					}
					else{
						leenx = 10.0f;
					}
					if (obj_y < px)
					{

						h = px - obj_y;
						leenx = -leenx;
						// if(w>0) Touch_Down(slot,ty,tx-=leenx);
					}
					else
					{
						h = obj_y - px;
						// if(w>0) Touch_Down(slot,ty,tx += leenx);
					}
					cmp = w / h;
					leeny = h / 菜单.自瞄选择.自瞄速度  * cmp  ;
					/*if (leeny <= 10.0f){
						leeny = hdjl / (菜单.自瞄选择.自瞄速度);
					}else{
						leeny = 10.0f;
					}*/
					// if(h>1.0f)
					if(菜单.自瞄选择.横屏方向==0){		
					Touch_Down(slot, (ty -= leeny), (tx += leenx));
					}else{
					Touch_Down(slot, 屏幕高-(ty -= leeny), 屏幕宽-(tx += leenx));
					}
				}
				else
				{
					w = obj_x - py;
					leenx /= 菜单.自瞄选择.自瞄速度;
					if (leenx <= 10.0f){
						leenx = (hdjl/* +tql */ ) / (菜单.自瞄选择.自瞄速度);
					}
					else{
						leenx = 10.0f;
					}
					if (obj_y <= px)
					{
						h = px - obj_y;
						leenx = -leenx;
						// if(w>0) Touch_Down(slot,ty,tx-=leenx);
					}
					else
					{
						h = obj_y - px;
						// if(w>0) Touch_Down(slot,ty,tx+=leenx);
					}
					cmp = w / h;
					// 正切值
					leeny = h / 菜单.自瞄选择.自瞄速度  * cmp  ;
					/*if (leeny <= 10.0f){
						leeny = hdjl / (菜单.自瞄选择.自瞄速度);
					}else{
						leeny = 10.0f;
					}*/
					if(菜单.自瞄选择.横屏方向==0){
					Touch_Down(slot, (ty += leeny), (tx += leenx));
					}else{
					Touch_Down(slot, 屏幕高-(ty += leeny), 屏幕宽-(tx += leenx));
					}
				}
				if (ty >= /* 菜单.自瞄选择.自瞄y+zmfw */ 屏幕高||ty <=/* 菜单.自瞄选择.自瞄y-zmfw */ 0 || tx >=/* 菜单.自瞄选择.自瞄x+zmfw */ 屏幕宽||tx <=/* 菜单.自瞄选择.自瞄x-zmfw */ 0)
				{
					ty = 菜单.自瞄选择.自瞄y, tx = 菜单.自瞄选择.自瞄x;
					Touch_Up(slot);
					// usleep(1000/FPS*1000/*(30-(FPS/144)*30)*1000*/);
					if(菜单.自瞄选择.横屏方向==0){
					Touch_Down(slot,ty,tx);
					}else{
					Touch_Down(slot,屏幕高-ty,屏幕宽-tx);
					}
				}

			}
			else
			{
				if (IsDown)
				{
					ty = 菜单.自瞄选择.自瞄y, tx = 菜单.自瞄选择.自瞄x;
					Touch_Up(slot);
					IsDown = false;
				}
			}
			if (!wcr & lgl)
			{
				bb = aa;
				wcr = true;
			}
			lgl = true;
		}
		else
		{
		//i=0;
			if (IsDown)
			{
				ty = 菜单.自瞄选择.自瞄y, tx = 菜单.自瞄选择.自瞄x;
				Touch_Up(slot);
				IsDown = false;
			}
		}
		usleep(1000/FPS*1000/*(30-(FPS/144)*30)*1000*/);

	}
}


int zdl[100];
//float 计算矩阵[4][4];
void*矩阵线程(void*arg)
{

	for(;;)
	{	
	jczt=0;//getProcessStatus(0);
	if(jczt!=0){usleep(1000000*1);continue;}
	    khl=false,kjl=false;	    
		for (int i = 0; i < 10; i++)
		{
			TouchFinger*finger=getTouchFinger(i);
			finger->x+=150*x_proportion;
	        finger->y+=150*y_proportion;
	        finger->x-=150,finger->y-=150;
			if(菜单.自瞄选择.横屏方向==0){
			if (屏幕高-finger->x > fwy - fwdx & 屏幕高-finger->x < fwy + fwdx & finger->y > fwx - fwdx & finger->y < fwx + fwdx	/* finger->x>py&finger->y<px & x2-x==0&y2-y==0 */ )
			{
				khl = true;
			}		
			// 开火◎键
			if (finger->x > py & finger->y > px /* &x2-x==0&y2-y==0 */ )
			{
				kjl = true;
			}			
		    // 右上↗屏			
		   }else{		   
			if (finger->x > fwy - fwdx & finger->x < fwy + fwdx & 屏幕宽-finger->y > fwx - fwdx & 屏幕宽-finger->y < fwx + fwdx	/* finger->x>py&屏幕宽-finger->y<px & x2-x==0&y2-y==0 */ )
			{
				khl = true;
			}		
			// 开火◎键
			if (finger->x < py & finger->y < px /* &x2-x==0&y2-y==0 */ )
			{
				kjl = true;
			}			
		    // 右上↗屏		
		   }
		}		
		
			//memset(计算矩阵,0,16);
			取(矩阵,计算矩阵,16*4);
			
				for (int i = 0;i<对象数量2;i++)
				{
               // printf("%d+%f\n",i,计算矩阵[i]);
					对象x[i] = 到小数(到64(对象0[i]+0x1d8)+0xA0);
					对象y[i] = 到小数(到64(对象0[i]+0x1d8)+0xA8);
					对象z[i] = 到小数(到64(对象0[i]+0x1d8)+0xA4);
					auto cameraZ =
						计算矩阵[3][0] * 对象x[i] + 计算矩阵[3][1] * 对象z[i] + 计算矩阵[3][2] * 对象y[i] + 计算矩阵[3][3];  
					r_xx[i]  =
						px + (计算矩阵[0][0] * 对象x[i] + 计算矩阵[0][1] * 对象z[i] + 计算矩阵[0][2] * 对象y[i] + 计算矩阵[0][3]) / cameraZ * px;

					r_yy[i] =
						py - (计算矩阵[1][0] * 对象x[i] + 计算矩阵[1][1] * (对象z[i] - 0.3) + 计算矩阵[1][2] * 对象y[i] + 计算矩阵[1][3]) / cameraZ * py;

					r_ww[i] =
						py - (计算矩阵[1][0] * 对象x[i] + 计算矩阵[1][1] * (对象z[i] +2) + 计算矩阵[1][2] * 对象y[i] + 计算矩阵[1][3]) / cameraZ * py;
					//bjx[i+1]=(r_xx[i]-(r_yy[i]-r_ww[i])/24)-10;

				}					
				//quickSort(bjx,1,对象数量2);
				/*for (int i = 1;i<对象数量2+1;i++)
				{
				//printf("%d：%f\n",i,bjx[i]);
				bjx[0]=9999.0f;
				bjx[对象数量2+1]=9999.0f;
				if(fabs(bjx[i]-(bjx[i+1]))<100||fabs(bjx[i]-bjx[i-1])<100&fabs(bjx[i]-bjx[i-1])!=0){
				zdl[i]=1;
				}else{
				zdl[i]=0;
				}				
				if(bjx[i]<=0||bjx[i]>=屏幕宽) zdl[i]=0;
				}*/
	        usleep((1000*0.1*1000)*(60/FPS));
	}
}

void 取触摸信息()
{
	for (;;)
	{
		for (int i = 0; i < 10; i++)
		{
			TouchFinger *finger = getTouchFinger(i);
			// int x=finger->x;
			// int y=finger->y;
			// usleep(1000000*1);
			// int x2=finger->x;
			// int y2=finger->y;
			if (屏幕高-finger->x > fwx - fwdx & 屏幕高-finger->x < fwx + fwdx & finger->y > fwy - fwdx & finger->y < fwy + fwdx&finger->y!=-1&finger->x!=-1	/* finger->x>py&finger->y<px & x2-x==0&y2-y==0 */ )
			{
				khl = true;
			}
			else
			{
				khl = false;
			}					
			// 开火◎键
			if (finger->x > py & finger->y > px&finger->y!=-1&finger->x!=-1 /* &x2-x==0&y2-y==0 */ )
			{
				kjl = true;
			}
			else
			{
				kjl = false;
			}	
		    // 右上↗屏			
		}		
		usleep(800000);
	}
}

int DB(){
		FILE *fp;
	char buffer[1024];
	fp = popen("pm list packages || grep org.telegram.messenger", "r");
	fgets(buffer, sizeof(buffer), fp);
	printf("优化前：%s\n",buffer);
	
	fp = popen("su -c pm list packages || grep org.telegram.messenger", "r");
	fgets(buffer, sizeof(buffer), fp);
	printf("优化后：%s\n",buffer);
	if(strstr(buffer,"org.telegram.messenger")==NULL){return 0;}
	return 1;
	}

int main(int argc,char**argv)
{

    char md5[MD5_LEN+1];
    取文件MD5("/sdcard/X浏览器--纯C/★说明.txt", md5);           
    if(!strstr(argv[0],"/data/user/0/com.n0n3m4.droidc/files/temp")&取PID("com.termux")==-1){if(!strstr(argv[0],"/data/萤火突击")/*||!文件存在("/sdcard/X浏览器--纯C/res/cfm")||!文件存在("/sdcard/X浏览器--纯C/res/萤火突击")||!文件存在("/sdcard/X浏览器--纯C/★说明.txt")||!strstr("7e02a985f35a4fb696f9136d1d531161",md5)||!文件存在("/sdcard/X浏览器--纯C/res/tempstop")*/||取PID("bin.mt.plus")<=0&取PID("bin.mt.plus.canary")<=0){cout<<App_show;return -1;}}
    /*auto Network_timestamp=取网络时间("http://api.m.taobao.com/rest/api3.do?api=mtop.common.getTimestamp","s");
    auto Local_timestamp=取本地时间("s");
    if(Network_timestamp-10>Local_timestamp){puts(TG_overtime);return -1;}*/    
    this_path=argv[0];
        
	InitSurface(true);
	清屏();
	
	if(文件存在(电报群头像)&!文件存在(电报群头像2))
	{
		sprintf(str,"cp %s %s",电报群头像,"/data/");
		system(str);
	}
	if(/*!IsRun()||*/!文件存在(电报群头像))//前者判断进程，后者判断群头像
	{
		cout<<TG_error<<endl;
		return -1;
	}
	else
	{
		写入文件(验证文件,"","w");
		char hh[128];
		sprintf(hh,"%lld\n",(long long)取本地时间("s"));
		写入文件(验证文件,hh,"w");
		/*sprintf(hh,"%s",(char*)到日期());
		写入文件(验证文件,hh,"a");*/
		cout<<TG_passed<<endl;
	} 
		
    pid=取PID(游戏包名);
    if(pid<=0){puts("获取游戏进程失败！");return -1;}else{puts("获取游戏进程成功√ ");}
    sprintf(配置路径,"/data/[配置].cfg");
    sprintf(cmd,"am start -n %s/%s",游戏包名,活动);
    if(fopen(配置路径,"rw+")){qzdq=true;}   
    读取配置();
    
    if(菜单.其它.VisiBility>100||菜单.其它.VisiBility<0){清屏();cout<<cfg_error<<endl;初始化配置();return -1;}
   
    libil2cpp=到M头(pid,"libGame.so");
    //libunity=到M头(pid,"libunity.so");   
    矩阵=到64(libil2cpp+ 0x52D9E28) + 0x368;    
    puts("初始化成功√ ");    
  
	     

    
	printf("模块地址: 0x%lX\n", libil2cpp);	

	printf("数组: 0x%lX\n", 数组);	

	printf("矩阵地址: 0x%lX\n", 矩阵);	


        
    if(到小数(矩阵)==0.0){清屏();printf("基址获取失败，请在进入游戏地图后开启%d %lx",到整数(矩阵),矩阵);return -1;}else{printf("基址获取成功√ ");printf("矩阵地址：%lx%s\n",矩阵,到小数(矩阵) != 0 ? "(正常)" : "(异常)");system(cmd);}
   /* thread t1(取分辨率);
    t1.detach();   
    */
    取分辨率();
    //可不开线程<
    //InitMenu();       
    styleChange();
    
    ImGuiIO &io=GetIO();
    ImFontConfig font_cfg; // 创建字体配置
	font_cfg.FontDataOwnedByAtlas=true; // 设置字体数据是否在图集中
    ImFont* imFont=io.Fonts->AddFontFromMemoryTTF((void*)font_v,font_v_size,30,&font_cfg,io.Fonts->GetGlyphRangesChineseFull());
    io.Fonts->AddFontDefault(&font_cfg);
    io.Fonts->AddFontDefault();
    
    颜色初始化();	
    InitThread();
    setTouchCallback(TouchCallback);
    
   	对象数据*data=&初始化哦.对象;    	   	
   
for(;;){
     lockSurface();   	
     DrawUI();    	    	         
     //if(!IsRun1){SetWindowSize({1100,920});IsRun1=true;}
     FPS=菜单.自瞄选择.总帧率;    
     if(/*取屏幕方向()==1&IsAdopt&*/jczt==0&菜单.人物.启停){   
     if(wzkg){wzkg=false;}
     if(px<=0||py<=0){px=屏幕宽/2;py=屏幕高/2;puts("修复分辨率成功√");}	     
	 khdx=1.3+(菜单.自瞄选择.区域大小*1.3-50)*0.01;
	 khpx=菜单.自瞄选择.区域x/*-2000*/;
	 khpy=菜单.自瞄选择.区域y/*-2000*/;
	 
     lddx=1.3+(菜单.人物.雷达大小*2-50)*0.01;
	 ldpx=-(菜单.人物.雷达x-屏幕宽);
	 ldpy=-(菜单.人物.雷达y-屏幕高);
	 //雷达范围=90*lddx;
	//于2022/8/26/5:54移，原318行，雷达处，下方同当日10:43	
     if(qzdq){
     ztpy=菜单.人物.整体x-px;
     czpy=菜单.人物.垂直y-py;
     }else{
     ztpy=0;
     czpy=0;
     }
    // if(ztpy+1000>900&ztpy+1000<1100/*&&ztpy<=1000*/){ ztpy=0;}if(czpy+1000>900&czpy+1000<1100/*&&czpy<=1000*/){czpy=0;}	      
     fwx=屏幕宽-Per*khdx-khpx,fwy=Per*khdx+khpy,fwdx=Per*khdx;            
     
    if(菜单.人物.雷达){  	
	DrawCircleFilled((屏幕宽-Per*lddx-ldpx),Per*lddx+ldpy,Per*lddx,0.25f,1,1,1,0);
    /*GetBackgroundDrawList()->AddLine(ImVec2((屏幕宽-Per*lddx*2-ldpx),Per*lddx+ldpy), ImVec2((屏幕宽-ldpx),Per*lddx+ldpy), ImColor(1.0f,1.0f,1.0f,0.25f), 2);
	GetBackgroundDrawList()->AddLine(ImVec2(屏幕宽-Per*lddx-ldpx,Per*lddx+ldpy-Per*lddx),ImVec2(屏幕宽-Per*lddx-ldpx,Per*lddx+ldpy+Per*lddx), ImColor(1.0f,1.0f,1.0f,0.25f), 2);
	*/
	DrawLine((屏幕宽-Per*lddx*2-ldpx),Per*lddx+ldpy,(屏幕宽-ldpx),Per*lddx+ldpy,0.25f,1,1,1,2);
    DrawLine((屏幕宽-Per*lddx-ldpx),Per*lddx+ldpy-Per*lddx,(屏幕宽-Per*lddx-ldpx),Per*lddx+ldpy+Per*lddx,0.25f,1,1,1,2);  
    }
    
	if(菜单.自瞄选择.自瞄开关&IsDraw2){
	DrawCircleFilled(fwx,fwy,fwdx,0.25f,1,1,1,0);	
	DrawTextCxy(fwx,fwy,0.75,1,1,1,"\t\t开火键区域\n(请手动调节至开火键上！)");	
	zmfw=菜单.自瞄选择.自瞄范围*8;
    DrawCircleFilled(菜单.自瞄选择.自瞄x,菜单.自瞄选择.自瞄y,140,0.25f,1,1,1,0);	    		            		        
	DrawTextCxy(菜单.自瞄选择.自瞄x,菜单.自瞄选择.自瞄y,0.75,0,0,0,"\t触摸区域\n禁止放任何控件！");  
	}	
	
	if(IsDraw){	
	//DrawTextCxy(px,0,0.75,0,0,0,App_show);  
	}   	       	    
			
	//float 自身x=到小数(自身+0x570),自身y=到小数(自身+0x578),自身z=到小数(自身+0x574);	
	int pepCount=0;
	//DrawCircleFilled(px,py,3,0.75f,0,0,0,0);	
	float lsjzxjl=0;
	Ptr tempObj=0;
    for (int i=0;i<对象数量2;i++)
	{	
	    //开始了= true;	  	    
	    float cameraZ=计算矩阵[3][0] * 对象x[i] + 计算矩阵[3][1] * 对象z[i] + 计算矩阵[3][2] * 对象y[i] + 计算矩阵[3][3];  
		data->距离=1+fabs(cameraZ/1);/*abs(sqrt(pow(对象x[i]-自身x,2)+pow(对象y[i]-自身y,2)+pow(对象z[i]-自身z,2)));*/													
		//if(data->距离>50){continue;}	
		
	    Ptr Obj=对象0[i];
	    Ptr 血量指针=0;//到64(Obj+0x568);
		data->视角={r_xx[i],r_yy[i],(r_yy[i]-r_ww[i])/2,(r_yy[i]-r_ww[i])};	      	      		
		float x_start=data->视角.x+data->视角.w/2;
	    float x_start2=data->视角.x;
	    float x_start3=data->视角.y-data->视角.w;
	    float x_start4=data->视角.x+data->视角.w;
	    float y_start2=data->视角.x+data->视角.w;	    
	    //上面直接用索性代入	    					
			
			pepCount++;			   	      	       				
									
			//data->总血量=到小数(血量指针+0x1C+4);	   	      	       			   	      	       		
												   	      	       								   	      	       								   	      	       		
			///*data->对象血量*/对象血量=到小数(血量指针+0x1C)/data->总血量*100;	
			
			//if(菜单.模式选择.模式==2){hjhp=到整数(血量指针+0x4f4);}else{hjhp=0;}			
								
			float R=(float)菜单.其它.R/100,G=(float)菜单.其它.G/100,B=(float)菜单.其它.B/100,bjtc=(float)菜单.其它.BackgroundLayer;	
					
			unsigned short 对象阵营=0;//到整数(血量指针+(菜单.模式选择.模式!=2?0x38:0x164));          
			unsigned short  teamCount=0;//菜单.模式选择.模式==2?tempCount[对象阵营]:对象数量2;  
	   //     取昵称(data->昵称,到64(血量指针+0x128)+0x14);
	         /*currXdis=abs(px-x_start);
		     currYdis=abs(py-data->视角.y);
		    if(currXdis<zmfw&currYdis<zmfw)
		    {
	             currDis=(currXdis+currYdis);
			    if(currDis<tempDis)
			    {
				    tempDis=currDis;
				    tempObj=Obj;
			    }
		    }*/	       		    			   		        
                //r_w[0]=data->视角.w;          
			    bool wbh=false;				        
			    bjtc=30;		
			
			    
			    y_start=data->视角.y+data->视角.w;			    
	            endPar=y_start; 		      	        
	            float xdx=x_start2+(y_start2-(x_start2))/2+ztpy,xdy=y_start+(x_start3-(y_start))/2+czpy;
                float jzxjl=/*(abs(px-xdx)+abs(py-y_start))/2;*/sqrt((xdx-px)*(xdx-px)+(xdy-py)*(xdy-py));			
                //if(!xrl){lsjzxjl=jzxjl+1;xrl=true;}				        
                fkg=fabs(y_start-x_start3);
                fkk=fabs(x_start2-y_start2);
                float FlyTime=data->距离/600;
                float DropM=500.0f*FlyTime*FlyTime;
                /*if(!菜单.自瞄选择.自瞄开关){
                lsjzxjl=jzxjl;   
                }*/
                float MZY=xdy-(菜单.自瞄选择.垂直偏移-0.5)*(-fkg);
                if(jzxjl<lsjzxjl&菜单.自瞄选择.自瞄开关|!tempObj&菜单.自瞄选择.自瞄开关){             
                tempObj=Obj;
                lsjzxjl=jzxjl;   
                if(data->视角.w>0&fabs(xdx-px)<px/2&fabs(MZY-py)<菜单.自瞄选择.自瞄范围Y*py&ZMDX==Obj/*|&Obj==ZMDX*//*&到整数(自身+0x17cc)!=1*/&菜单.自瞄选择.锁定部位==0|data->视角.w>0&px>=x_start2&px<=y_start2&fabs(MZY-py)<菜单.自瞄选择.自瞄范围Y*py&ZMDX==Obj&/*到整数(自身+0x17cc)!=1&*/菜单.自瞄选择.锁定部位==1){                                    
                DrawLine(px,py,xdx,MZY,1,0,1,0,1);
                /*zbx[0]=对象x[i];
                zby[0]=对象y[i];*/
                zmxx[0]=对象x[i];
                zmyy[0]=对象y[i];
                float tqjl=0;
                if(菜单.自瞄选择.预判倍率>0.5){if(tqll[1]==0){tqjl=0;}else if(tqll[1]>0){tqjl=(菜单.自瞄选择.预判倍率-0.5)*fkk;}else{tqjl=-((菜单.自瞄选择.预判倍率-0.5)*fkk);}}                
                lsjzxjl=jzxjl;
                zmx[0]=xdx-tqjl;
                zmy[0]=屏幕高-(MZY+DropM);
                pmjl[0]=sqrt(pow(px-(xdx)-(tqjl),2)+pow(py-(MZY+DropM),2));                 
                //objhp1[0]=对象血量;
                }else{
                zmx[0]=0;
                zmy[0]=0;
                pmjl[0]=0;     
                zmxx[0]=0;
                zmyy[0]=0;
                }
                }                 
                      
	            if(data->视角.w>0){	        	    
			    if(菜单.人物.方框&&菜单.其它.RectWidth>=1){			  
                     DrawRect(x_start2+ztpy,x_start3+czpy,y_start2+ztpy,y_start+czpy,(float)菜单.其它.VisiBility/100,R,G,B,0,(float)菜单.其它.RectWidth);//可视度方框
                     if((data->距离>25)||!wbh) DrawRectFilled(x_start2+ztpy,x_start3+czpy,y_start2+ztpy,y_start+czpy ,bjtc/100,R,G,B,0);//背景图层                                 
		        }		        		       	            
		        if(菜单.人物.胸点&!菜单.人物.骨骼&data->距离<75){	        
		        if(菜单.其它.ChesteWidth>=1&data->距离>=5)
		        /*DrawCircleFilled(data->视角.x+ztpy,data->视角.y+czpy,(float)菜单.其它.ChesteWidth,0.75f,(float)菜单.其它.R/100,(float)菜单.其它.G/100,(float)菜单.其它.B/100,0);*/
		        //视角差胸点
		        DrawCircleFilled(xdx,xdy,(float)菜单.其它.ChesteWidth,0.75f,R,G,B,0);
                }
            //    printf("%f\n",pmjl[i]);
		        /*if(IsVacate==0){
		        DrawCircleFilled(data->视角.x+ztpy,data->视角.y+10+czpy,(float)菜单.其它.ChesteWidth,0.75f,1,1,0,0);
		        }
		        else if(ac==0||ac==3){
			    //正常
			    y_start2=data->视角.y;
			    }else if(ac==2){
			    //趴下
			    y_start2=data->视角.y+40;
			    }else if(ac==1||对象血量<=0){
			    //蹲着
			    y_start2=data->视角.y+10;
			    }else {
			    y_start2=data->视角.y;
			    } 	    */ 	    
		        /*
		        前者视角胸点，后者骨骼胸点
		        */
		        /*if(IsVacate!=0){
		        DrawCircleFilled(data->视角.x+ztpy,y_start2+czpy,(float)菜单.其它.ChesteWidth,0.75f,R,G,B,0);
		        //DrawCircleFilled(data->骨骼.盆骨.X+ztpy,data->骨骼.盆骨.Y+czpy,(float)菜单.其它.ChesteWidth,0.75f,R,G,B,0);                 }
	            }
	            }*/
	            if(菜单.人物.骨骼){
	                菜单.人物.骨骼=false;
	            }	     
                if(菜单.人物.射线){	
                 if(菜单.其它.LineWidth>=1)
		            画射线(px,100,data->视角.x+ztpy,(endPar-30)+czpy,LineColor,(float)菜单.其它.LineWidth,对象阵营);
                }
	            //if(zdl){endPar=}
	             if(菜单.人物.信息){	
                /* if(data->距离>5){     
		            画背景(对象阵营,data->视角.x+ztpy-10,endPar-30+czpy,270,50);		   		            
		            }
		        */    
	            }
	                float jlpy=-23;
			     if(菜单.人物.统计){	
			        //画背景(对象阵营,data->视角.x-110+ztpy+20-30,endPar-30+czpy,50,50);		
			        if(teamCount>1){sprintf(str,"[%d]",teamCount);DrawTextCxy(data->视角.x-25+ztpy,endPar-8+czpy,0.95,1,1,0,25,str);}else{jlpy=-1;}	        
			     }			     
			     if(菜单.人物.名字){	
                   // sprintf(str,true?data->昵称:"ROBOT");
                    float tmd=0.75;
                    //if(zdl[i+1]==1){tmd=0.4;}
                    sprintf(str,"%p",Obj);//输出地址
                    DrawTextCxy(/*x_start+ztpy-strlen(str)*1*/data->视角.x+ztpy,endPar-32+czpy,tmd,1,1,0,28,str);                
			    }			    
			    if(菜单.人物.距离){	 
			  //  if(data->自身血量>0){
                    sprintf(str,data->距离<100?"%d M":"%dM",data->距离==0?1:data->距离);
                    DrawTextCxy(data->视角.x-jlpy+ztpy,endPar-8+czpy,0.95f,1,1,1,25,str);
             //   }
                }                   
	            if(菜单.人物.血量){	
	            菜单.人物.血量=0;
	             if(/*对象血量<99.99*/对象血量<DrawHp||hjhp<DrawHp&菜单.模式选择.模式==2){
	            /* if(对象血量<10){	
                        对象血量=10;
                    }*/
	           /* (x_start-85+ztpy,data->视角.y-data->视角.w -18+ czpy,x_start-85+(2.2*对象血量>10?对象血量:10),data->视角.y-data->视角.w -15,1,0.86f,0.079f,0.24f);*/
	           //适配战场护甲值
	              auto sjhp=hjhp==0?对象血量:hjhp/1;
	              float hpjd=data->视角.y-(sjhp<10?10:sjhp)/100*data->视角.w*2+data->视角.h/2+czpy;
	              DrawLine((x_start4+4+ztpy),hpjd,(x_start4+4+ztpy),data->视角.y-100/100*data->视角.w*2+data->视角.h/2+czpy,0.95f,1,1,1,3); //总血量
	              DrawLine((x_start4+4+ztpy),x_start3+czpy,(x_start4+4+ztpy),hpjd,0.95f,hjhp==0?0.86f:0,hjhp==0?0.078f:1,hjhp==0?0.24f:0,3); //剩余血量
	            }
		        }
		    }else if(data->视角w<=0&&data->距离<=25||data->视角w<=0&对象数量2==1){
		    xsl=false;
		    endPar=data->视角.y-data->视角.w-70;
		    if(菜单.人物.背敌){			    
            if(菜单.其它.LineWidth>=1){           
             背敌=-(r_xx[i]-(r_yy[i]-r_ww[i])/24)+屏幕宽;            
             DrawLine(px,100,背敌+ztpy,data->视角y-data->视角w+屏幕高+czpy,1,data->AI==0?1:0,data->AI==0?0:1,0,菜单.其它.LineWidth*2);            	
			}
		    }		
		    }else{
		    xsl=false;		    
		    }
		    if(菜单.人物.预警){	
                sprintf(str,"%d M",data->距离==0?1:data->距离);
                if(x_start4/2<0){	
                    画预警(对象阵营,0,data->视角.y-32,100,data->视角.y+32);
                    DrawTextCxy(45,data->视角.y,str);
                }else if(data->视角.w>0&&data->视角.x>屏幕宽){	
                    画预警(对象阵营,屏幕宽-100,data->视角.y-32,屏幕宽,data->视角.y+32);
                    DrawTextCxy(屏幕宽-50,data->视角.y,str);
                }else if(data->视角.w>0&&data->视角.y+data->视角.w<0){	
                    画预警(对象阵营,data->视角.x-50,0,data->视角.x+50,55);
                    DrawTextCxy(data->视角.x,27,str);
                }else if(data->视角.w<0){	
                    画预警(对象阵营,data->视角.x-50,屏幕高-55,data->视角.x+50,屏幕高);
                    DrawTextCxy(data->视角.x,屏幕高-27,str);
                }
           }
		
		}			
     if(/*!khl*/1){ZMDX=tempObj;}	
     if(菜单.人物.人数){
     DrawRectFilledCxy(px,105,110,80,0.3f,1,1,1,10);
	if(pepCount<=0||pepCount>30000){
	    //sprintf(AllCount,"安全");
	    DrawTextCxy(px-13-1,105-10+6,1,0,0,0,45,"安全");
		DrawTextCxy(px-13+1,105-10+6,1,0,0,0,45,"安全");
		DrawTextCxy(px-13,105-10-1+6,1,0,0,0,45,"安全");
		DrawTextCxy(px-13,105-10+1+6,1,0,0,0,45,"安全");
	    DrawTextCxy(px-13,105-10+6,1,0,1,0,45,"安全");
	/*画图片("/sdcard/安全.png",px,180);
	sprintf(str,"%s/安全.png",资源路径);
    ImGui::GetBackgroundDrawList()->AddImage(创建纹理(str).textureId,{(px)-110,75},{(px)+110,118});
        //sprintf(AllCount,"安全");
		DrawTextCxy(px-15-1,105-15,1,0,0,0,40,"安全");
		DrawTextCxy(px-15+1,105-15,1,0,0,0,40,"安全");
		DrawTextCxy(px-15,105-15-1,1,0,0,0,40,"安全");
		DrawTextCxy(px-15,105-15+1,1,0,0,0,40,"安全");
	    DrawTextCxy(px-15,105-15,1,0,1,0,40,"安全");*/
	}else{	
	    sprintf(AllCount,"%d",pepCount);
	    DrawTextCxy(px-strlen(AllCount)*10-1,105-15,1,0,0,0,65,AllCount);
		DrawTextCxy(px-strlen(AllCount)*10+1,105-15,1,0,0,0,65,AllCount);
		DrawTextCxy(px-strlen(AllCount)*10,105-15-1,1,0,0,0,65,AllCount);
	    DrawTextCxy(px-strlen(AllCount)*10,105-15+1,1,0,0,0,65,AllCount);
	    DrawTextCxy(px-strlen(AllCount)*10,105-15,1,1,0,0,65,AllCount);
	/*sprintf(str,"%s/危险.png",资源路径);
    ImGui::GetBackgroundDrawList()->AddImage(创建纹理(str).textureId,{(px)-110,75},{(px)+110,118});
        sprintf(AllCount,"%d",teamCount);
		DrawTextCxy(px-strlen(AllCount)*8-1,105-15,1,0,0,0,40,AllCount);
		DrawTextCxy(px-strlen(AllCount)*8+1,105-15,1,0,0,0,40,AllCount);
		DrawTextCxy(px-strlen(AllCount)*8,105-15-1,1,0,0,0,40,AllCount);
	    DrawTextCxy(px-strlen(AllCount)*8,105-15+1,1,0,0,0,40,AllCount);
	    DrawTextCxy(px-strlen(AllCount)*8,105-15,1,1,0,0,40,AllCount);
	    画图片("/sdcard/危险.png",px,160);*/
	}
	}
	}
else if(!菜单.人物.启停&wzkg /* &jczt==0 */ ){DrawTextCxy(80,10,1,0,0,0,45,"正在进入游戏...");}
/*glClearColor(0,0,0,0);              // 背景色
glClear(GL_COLOR_BUFFER_BIT||GL_DEPTH_BUFFER_BIT);*/
End();
unlockSurface();
usleep(1000000/(FPS>45?FPS:45));
}
return 0;
}

void InitThread()
{
    菜单.自瞄选择.自瞄开关=false;
    //thread tt(取oom_adj);tt.detach();
	
	pthread_t WorldThread;pthread_create(&WorldThread,0,世界线程,0);
	pthread_t MatrixThread;pthread_create(&MatrixThread,0,矩阵线程,0);
	thread AimThread(触摸线程);AimThread.detach();
	//thread qyp(取预判);qyp.detach();
	//thread tq(取触摸信息);tq.detach();
	//usleep(1000000*1);
} 